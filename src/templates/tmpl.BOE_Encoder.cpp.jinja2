{%- macro renderCamelCase(field) -%}
    {# # Converts a field name to camelCase #}
    {{- field[:1] | lower }}{{ field[1:] -}}
{%- endmacro -%}

{%- macro renderMemberName(field) -%}
    {# # Appends an underscore to camelCase field name #}
    {{- renderCamelCase(field) -}}_
{%- endmacro -%}

{%- macro renderBaseEncoders() -%}
    {# # Base encoding functions for different field types #}

    {# # Template for encoding primitive types or enums #}
    template <typename U>
    inline void _encode(char *&start, char *end, const U &field, Status &status) noexcept
    {
        {# # Exit early if not parsing #}
        if (status.getStatus() != StatusEnum::PARSING)
            return;  

        {# # Check buffer overflow #}
        if (start + sizeof(field) > end)  
        {
            status.updateStatus(StatusEnum::BUFFER_OVERFLOW);
            return;
        }

        {# # Ensure enums are valid (not set to UNKNOWN) #}
        if constexpr (std::is_enum<U>::value)
        {
            if (field == U::UNKNOWN)
            {
                status.updateStatus(StatusEnum::INVALID_OBJECT);
                return;
            }
        }

        {# # Write field data to the buffer #}
        *reinterpret_cast<U *>(start) = field;
        start += sizeof(field);
        {# # Update the start pointer #}
        status.updateNextStart(start);  
    }

    {# # Specialization for encoding vectors of fields #}
    template <typename U>
    void _encode(char *&start, char *end, const std::vector<U> &field, Status &status) noexcept {
        {# // Early exit if parsing has stopped #}
        if (status.getStatus() != StatusEnum::PARSING)
            return;  
        {# // Encode each element in the vector #}
        for (const auto &element : field) {
            _encode(start, end, element, status);
            if (status.getStatus() != StatusEnum::PARSING) return;  // Exit loop on overflow
        }
    }


    // Specialization for encoding vectors of fields dependent on bitfields
    template <typename U, typename B>
    void _encode(char *&start, char *end, const std::vector<U> &field, const std::vector<B> &bitfields, Status &status) noexcept
    {
        if (status.getStatus() != StatusEnum::PARSING)
            return;  

        for (const auto &element : field)
        {
            _encode(start, end, element, bitfields, status);
            {# # Stop if buffer overflow occurs #}
            if (status.getStatus() != StatusEnum::PARSING)
                return;  
        }
    }

    {# # Specialization for encoding fixed-size character arrays #}
    template <size_t len>
    void _encode(char *&start, char *end, const std::array<char, len> &field, Status &status) noexcept
    {
        {# # Exit early if not parsing #}
        if (status.getStatus() != StatusEnum::PARSING)
            return;  

        for (const auto &element : field)
        {
            _encode(start, end, element, status);
            {# # Stop if buffer overflow occurs #}
            if (status.getStatus() != StatusEnum::PARSING)
                return;  
        }
    }
{%- endmacro -%}

{%- macro renderMembers(prefix, data) -%}
    {# # Generate encoding logic for each member in a message or group #}
    {%- set firstOptional = [true] -%}
    {%- for member, details in data.Fields.items() -%}
        {%- set var = renderCamelCase(prefix) -%}

        {%- if details is string and 'Enum' not in details -%}
            {%- if 'metaData' in data and 'hasOptional' in data.metaData -%}
                {# # Check for optional bitfield presence #}
                if (group{{data.metaData.hasOptional}} [static_cast<uint8_t>({{data.metaData.message}}BitfieldIdx::{{member|upper}})].get{{data.metaData.message}}Bitfield() & (1 << static_cast<uint8_t>({{data.metaData.message}}BitIdx::{{member|upper}})))
                {
            {%- else -%}
                {%- if firstOptional -%}
                    {# # Initialize bitfields for optional fields #}
                    {%- do firstOptional.pop() -%}
                    auto bitfields = {{var}}.getGroup{{details}}();
                    size_t bitfieldIdx = 0;
                    size_t bitIdx = 0;
                {%- endif -%}
                bitfieldIdx = static_cast<uint8_t>({{prefix}}BitfieldIdx::{{member|upper}});
                bitIdx = static_cast<uint8_t>({{prefix}}BitIdx::{{member|upper}});
                if (bitfields.size() > bitfieldIdx and bitfields[bitfieldIdx].get{{prefix}}Bitfield() & (1 << bitIdx))
                {
            {%- endif -%}
        {%- endif -%}

        {%- if yamlData['Fields'][member]['dataType'] == 'char*' -%}
            {# # Encode fixed-size character array #}
            _encode(start, end, {{var}}.get{{member}}(), status);
        {%- else -%}
            {# # Encode primitive fields or groups #}
            _encode(start, end, {{var}}.get{{member}}(), status);

            {%- if details is mapping and 'ParamGroups' in details -%}
                {%- for group, groupSize in details.ParamGroups.items() -%}
                    {%- if 'metaData' in yamlData['Groups'][group] and 'hasOptional' in yamlData['Groups'][group]['metaData'] -%}
                        {# # Encode parameter groups with optional fields #}
                        _encode(start, end, {{var}}.getGroup{{group}}(), {{var}}.getGroup{{yamlData['Groups'][group].metaData.hasOptional}}(), status);
                    {%- else -%}
                        {# # Encode regular parameter groups #}
                        _encode(start, end, {{var}}.getGroup{{group}}(), status);
                    {%- endif -%}
                {%- endfor -%}
            {%- endif -%}
        {%- endif -%}

        {%- if details is string and 'Enum' not in details -%}
        {# # Close the optional field block #}
            }  
        {%- endif -%}
    {%- endfor -%}
{%- endmacro -%}

{%- macro renderGroups(data) -%}
    {# # Generate encoding functions for groups #}
    {%- for name, details in data.items() -%}
        // Specific encode function for Group{{name}} class {{"\n"}}
        {# encode for group with optional fields, and for normal group #}
        {%- if 'metaData' in details and 'hasOptional' in details.metaData -%}
            // Specific encode function for Group{{name}} class with optional fields{{"\n"}}
            inline void _encode(char*& start, char* end, const Group{{name}}& group{{(name)}}, const std::vector<Group{{details.metaData.hasOptional}}>& group{{details.metaData.hasOptional}}, Status& status) noexcept
        {%- else -%}
            inline void _encode(char*& start, char* end, const Group{{name}}& group{{(name)}}, Status& status) noexcept
        {%- endif -%}
        {
            {# # Exit early if not parsing #}
            if (status.getStatus() != StatusEnum::PARSING)
                return;  
            {{renderMembers("Group" + (name), details)}}
        }
    {%- endfor -%}
{%- endmacro -%}

{%- macro renderMessages(data) -%}
    {# # Generate encoding functions for messages #}
    {%- for name, details in data.items() -%}
        void _encode(char*& start, char* end, const {{name}}& {{renderCamelCase(name)}}, Status& status) noexcept
        {
            {{renderMembers(name, details)}}
        }
    {%- endfor -%}
{%- endmacro -%}

#pragma once
#include "BOE_Msgs.h"
#include "/root/Subhash/src/common/status.h"
#include "/root/Subhash/src/common/utils.h"
{{"\n"}}

{# # Encoder class responsible for encoding various message types into binary format #}
template <typename HandlerType>
class Encoder {
    {{renderBaseEncoders()}}
    {{renderGroups(yamlData['Groups'])}}
    {{renderMessages(yamlData['Messages'])}}
public:
    {# # Public function to encode any message type #}
    template <typename T>
    void encode(const std::vector<char> &buffer, const T &msg, Status &status)
    {
        char *start = const_cast<char *>(buffer.data());
        char *end = start + buffer.size();
        HandlerType handler;
        _encode(start, end, msg, status);

        {# # Mark status as complete if parsing succeeded #}
        if (status.getStatus() == StatusEnum::PARSING)
            status.updateStatus(StatusEnum::COMPLETE);
        handler(status);
    }
};

{# // EOF #}
{# int main()
{
    LoginRequest loginRequest;
    Encoder encoder;

    loginRequest.setMessageLength(0x3d00);
    loginRequest.setSessionSubID("0001");
    loginRequest.setUsername("TEST");
    loginRequest.setPassword("TESTING");

    loginRequest.setGroupUnitSequences(GroupUnitSequences(0x000F, GroupUnitSequences::NoUnspecifiedUnitReplayEnum::TRUE, std::vector<GroupNumberOfUnits>{}));
    loginRequest.setGroupUnitSequences(GroupUnitSequences(0x000F, GroupUnitSequences::NoUnspecifiedUnitReplayEnum::TRUE, std::vector<GroupNumberOfUnits>{GroupNumberOfUnits(0x1, 0x0001bb4a), GroupNumberOfUnits(0x02, 0x00)}));

    // GroupUnitSequences groupUnitSequences;
    // GroupNumberOfUnits groupNumberOfUnits;

    // groupUnitSequences.setParamGroupLength(0x000F);
    // groupUnitSequences.setNoUnspecifiedUnitReplay(0x1);

    // groupNumberOfUnits.setUnitNumber(0x1);
    // groupNumberOfUnits.setUnitSequence(0x0001bb4a);
    // groupUnitSequences.setGroupNumberOfUnits(std::move(groupNumberOfUnits));

    // groupNumberOfUnits.setUnitNumber(0x02);
    // groupNumberOfUnits.setUnitSequence(0x00);
    // groupUnitSequences.setGroupNumberOfUnits(std::move(groupNumberOfUnits));

    // loginRequest.setGroupUnitSequences(std::move(groupUnitSequences));
    // loginRequest.setParamGroupLengthNoUnspecifiedUnitReplay(0, 3840);
    // loginRequest.setParamGroupTypeNoUnspecifiedUnitReplay(0, 128);
    // loginRequest.setNoUnspecifiedUnitReplay(0, 1);
    // loginRequest.setNumberOfUnits(0, 2);
    // loginRequest.setUnitNumber(0, 0, 1);
    // loginRequest.setUnitSequence(0, 0, 1253769472);
    // loginRequest.setUnitNumber(0, 1, 2);
    // loginRequest.setUnitSequence(0, 1, 0);

    // loginRequest.setParamGroupLengthMessageType(0, 2048);
    // loginRequest.setParamGroupTypeMessageType(0, 129);
    // loginRequest.setMessageType(0, 37);
    // loginRequest.setNumberOfReturnBitfields(0, 3);
    // loginRequest.setReturnBitfield(0, 0, 0);
    // loginRequest.setReturnBitfield(0, 1, 65);
    // loginRequest.setReturnBitfield(0, 2, 5);

    // loginRequest.setParamGroupLengthMessageType(1, 2816);
    // loginRequest.setParamGroupTypeMessageType(1, 129);
    // loginRequest.setMessageType(1, 44);
    // loginRequest.setNumberOfReturnBitfields(1, 6);
    // loginRequest.setReturnBitfield(1, 0, 0);
    // loginRequest.setReturnBitfield(1, 1, 65);
    // loginRequest.setReturnBitfield(1, 2, 7);
    // loginRequest.setReturnBitfield(1, 3, 0);
    // loginRequest.setReturnBitfield(1, 4, 64);
    // loginRequest.setReturnBitfield(1, 5, 0);

    // Properly allocating the buffer (start and end) based on required size
    size_t bufferSize = 1024;
    char buffer[bufferSize];
    char *start = buffer;
    char *end = buffer + bufferSize;

    // Encode the message
    Status status;
    status.updateNextStart(start);
    encoder.encode(start, end, loginRequest, status);

    // Output encoding result
    std::cout << status.getInfo() << std::endl;
    std::cout << "Next start pointer: " << static_cast<void *>(status.getNextStart()) << std::endl;

    // Calculate how many bytes were written
    size_t bytesWritten = status.getNextStart() - buffer;
    std::cout << "bytesWritten: " << bytesWritten << std::endl;

    // Print the buffer contents up to nextStart in hex
    std::cout << "Encoded buffer: ";
    for (size_t i = 0; i < bytesWritten; ++i)
    {
        std::cout << std::hex << static_cast<int>(static_cast<unsigned char>(buffer[i])) << " ";
    }
    std::cout << std::endl;

    return 0;
} #}